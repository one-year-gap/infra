name: central-release-orchestrator

on:
  workflow_call:
    inputs:
      source-repo:
        description: "owner/repo"
        required: true
        type: string
      source-sha:
        description: "merged commit sha on main"
        required: true
        type: string
    secrets:
      CENTRAL_REPO_TOKEN:
        required: true
      AWS_REGION:
        required: true
      CDK_DEFAULT_ACCOUNT:
        required: true
      AWS_DEPLOY_ROLE_ARN:
        required: true
      ADMIN_ALLOWED_CIDRS:
        required: true
      ADMIN_WEB_PORT:
        required: true
      CUSTOMER_WEB_PORT:
        required: true
      ADMIN_SERVER_PORT:
        required: true
      CUSTOMER_SERVER_PORT:
        required: true
      ADMIN_WEB_REPOSITORY:
        required: true
      API_SERVER_REPOSITORY:
        required: true
      DOMAIN_NAME:
        required: true
      VERCEL_APEX_IP:
        required: true
      DOMAIN_INTERNAL_NAME:
        required: true
      CUSTOMER_CERT_ARN:
        required: true
      ADMIN_CERT_ARN:
        required: true
      ADMIN_API_RUNTIME_SECRET_ARN:
        required: false
      CUSTOMER_API_RUNTIME_SECRET_ARN:
        required: false
      ADMIN_API_SECRETS_MANAGER_ARNS:
        required: false
      CUSTOMER_API_SECRETS_MANAGER_ARNS:
        required: false
      ADMIN_API_RUNTIME_SECRET_KMS_KEY_ARN:
        required: false
      CUSTOMER_API_RUNTIME_SECRET_KMS_KEY_ARN:
        required: false
      ADMIN_API_RUNTIME_SECRET_KMS_KEY_ARNS:
        required: false
      CUSTOMER_API_RUNTIME_SECRET_KMS_KEY_ARNS:
        required: false

  repository_dispatch:
    types: [release-request]

  workflow_dispatch:
    inputs:
      source-repo:
        description: "owner/repo"
        required: true
        default: "one-year-gap/api-server"
        type: string
      source-sha:
        description: "target sha (empty = HEAD of default branch)"
        required: false
        default: ""
        type: string
      release-label:
        description: "release label"
        required: true
        type: choice
        options:
          - release:major
          - release:minor
          - release:patch
      deploy-labels:
        description: "comma-separated deploy labels (ex: deploy:api-server,deploy:admin-web)"
        required: true
        default: "deploy:api-server"
        type: string

permissions:
  contents: write
  pull-requests: read
  id-token: write

concurrency:
  group: central-release-tag-creation
  cancel-in-progress: false

env:
  # Required AWS/Auth
  AWS_REGION: ${{ secrets.AWS_REGION }}
  CDK_DEFAULT_ACCOUNT: ${{ secrets.CDK_DEFAULT_ACCOUNT }}
  AWS_DEPLOY_ROLE_ARN: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
  # Required CDK app envs
  REGION: ${{ secrets.AWS_REGION }}
  ADMIN_ALLOWED_CIDRS: ${{ secrets.ADMIN_ALLOWED_CIDRS }}
  ADMIN_WEB_PORT: ${{ secrets.ADMIN_WEB_PORT }}
  CUSTOMER_WEB_PORT: ${{ secrets.CUSTOMER_WEB_PORT }}
  ADMIN_SERVER_PORT: ${{ secrets.ADMIN_SERVER_PORT }}
  CUSTOMER_SERVER_PORT: ${{ secrets.CUSTOMER_SERVER_PORT }}
  ADMIN_WEB_REPOSITORY: ${{ secrets.ADMIN_WEB_REPOSITORY }}
  API_SERVER_REPOSITORY: ${{ secrets.API_SERVER_REPOSITORY }}
  DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
  VERCEL_APEX_IP: ${{ secrets.VERCEL_APEX_IP }}
  DOMAIN_INTERNAL_NAME: ${{ secrets.DOMAIN_INTERNAL_NAME }}
  CUSTOMER_CERT_ARN: ${{ secrets.CUSTOMER_CERT_ARN }}
  ADMIN_CERT_ARN: ${{ secrets.ADMIN_CERT_ARN }}
  ADMIN_API_RUNTIME_SECRET_ARN: ${{ secrets.ADMIN_API_RUNTIME_SECRET_ARN }}
  CUSTOMER_API_RUNTIME_SECRET_ARN: ${{ secrets.CUSTOMER_API_RUNTIME_SECRET_ARN }}
  ADMIN_API_SECRETS_MANAGER_ARNS: ${{ secrets.ADMIN_API_SECRETS_MANAGER_ARNS }}
  CUSTOMER_API_SECRETS_MANAGER_ARNS: ${{ secrets.CUSTOMER_API_SECRETS_MANAGER_ARNS }}
  ADMIN_API_RUNTIME_SECRET_KMS_KEY_ARN: ${{ secrets.ADMIN_API_RUNTIME_SECRET_KMS_KEY_ARN }}
  CUSTOMER_API_RUNTIME_SECRET_KMS_KEY_ARN: ${{ secrets.CUSTOMER_API_RUNTIME_SECRET_KMS_KEY_ARN }}
  ADMIN_API_RUNTIME_SECRET_KMS_KEY_ARNS: ${{ secrets.ADMIN_API_RUNTIME_SECRET_KMS_KEY_ARNS }}
  CUSTOMER_API_RUNTIME_SECRET_KMS_KEY_ARNS: ${{ secrets.CUSTOMER_API_RUNTIME_SECRET_KMS_KEY_ARNS }}
  # Source repos
  API_SERVER_SOURCE_REPO: one-year-gap/api-server
  ADMIN_WEB_SOURCE_REPO: one-year-gap/admin-fe

jobs:
  resolve-context:
    runs-on: ubuntu-latest
    outputs:
      source_owner: ${{ steps.resolve.outputs.source_owner }}
      source_name: ${{ steps.resolve.outputs.source_name }}
      source_sha: ${{ steps.resolve.outputs.source_sha }}
      release_label: ${{ steps.resolve.outputs.release_label }}
      release_level: ${{ steps.resolve.outputs.release_level }}
      deploy_labels_json: ${{ steps.resolve.outputs.deploy_labels_json }}
    steps:
      - name: Resolve source + labels
        id: resolve
        uses: actions/github-script@v7
        env:
          IN_SOURCE_REPO: ${{ inputs.source-repo }}
          IN_SOURCE_SHA: ${{ inputs.source-sha }}
          IN_RELEASE_LABEL: ${{ inputs.release-label }}
          IN_DEPLOY_LABELS: ${{ inputs.deploy-labels }}
        with:
          github-token: ${{ secrets.CENTRAL_REPO_TOKEN }}
          script: |
            const releaseAllowed = ["release:major", "release:minor", "release:patch"];
            const deployAllowed  = ["deploy:admin-web", "deploy:api-server", "deploy:customer-web"];

            function splitRepo(full) {
              const parts = String(full || "").trim().split("/");
              if (parts.length !== 2 || !parts[0] || !parts[1]) {
                throw new Error(`invalid source-repo: ${full}`);
              }
              return { owner: parts[0], repo: parts[1], full: `${parts[0]}/${parts[1]}` };
            }

            function parseDeployLabels(raw) {
              return String(raw || "")
                .split(",")
                .map(v => v.trim())
                .filter(Boolean);
            }

            let sourceRepo;
            let sourceSha;
            let releaseLabel;
            let deployLabels = [];
            const centralRepo = `${context.repo.owner}/${context.repo.repo}`;

            if (context.eventName === "workflow_dispatch") {
              sourceRepo   = process.env.IN_SOURCE_REPO;
              sourceSha    = process.env.IN_SOURCE_SHA;
              releaseLabel = process.env.IN_RELEASE_LABEL;
              deployLabels = parseDeployLabels(process.env.IN_DEPLOY_LABELS);

            } else if (context.eventName === "workflow_call") {
              sourceRepo = process.env.IN_SOURCE_REPO;
              sourceSha  = process.env.IN_SOURCE_SHA;
              // workflow_call은 PR 라벨 자동 감지 경로로 진입하므로 sourceSha 필수

            } else if (context.eventName === "repository_dispatch") {
              sourceRepo = context.payload.client_payload?.source_repo;
              sourceSha  = context.payload.client_payload?.source_sha;

            } else {
              throw new Error(`unsupported event: ${context.eventName}`);
            }

            sourceRepo = String(sourceRepo || "").trim();
            sourceSha = sourceSha ? String(sourceSha).trim() : "";

            if (!sourceRepo) {
              throw new Error("source-repo is empty in event payload/input");
            }

            let { owner, repo, full } = splitRepo(sourceRepo);

            if (sourceSha) {
              const candidateRepos = Array.from(new Set([
                full,
                process.env.API_SERVER_SOURCE_REPO,
                process.env.ADMIN_WEB_SOURCE_REPO
              ].filter(Boolean).map(v => String(v).trim())));

              let matchedRepo = null;
              for (const candidate of candidateRepos) {
                const c = splitRepo(candidate);
                try {
                  await github.rest.repos.getCommit({
                    owner: c.owner,
                    repo: c.repo,
                    ref: sourceSha
                  });
                  matchedRepo = c.full;
                  break;
                } catch (e) {
                  if (e.status !== 404 && e.status !== 422) throw e;
                }
              }

              if (!matchedRepo) {
                throw new Error(`source-sha not found. source_sha=${sourceSha}, candidates=${candidateRepos.join(",")}`);
              }

              if (matchedRepo !== full) {
                core.notice(`source_repo corrected by SHA lookup: ${full} -> ${matchedRepo}`);
                ({ owner, repo, full } = splitRepo(matchedRepo));
              }
            }

            if (context.eventName === "repository_dispatch" && full === centralRepo) {
              core.warning(`source_repo resolved to central repo(${centralRepo}). Verify sender dispatch payload.`);
            }

            if (!releaseLabel || deployLabels.length === 0) {
              if (!sourceSha) {
                throw new Error("source-sha is required when labels are not manually provided");
              }

              const prs = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner,
                repo,
                commit_sha: sourceSha
              });

              const mergedToMain = prs.data
                .filter(pr => pr.merged_at && pr.base?.ref === "main")
                .sort((a, b) => new Date(b.merged_at) - new Date(a.merged_at));

              const pr = mergedToMain[0] || prs.data[0];
              if (!pr) {
                throw new Error(`No associated PR found for ${full}@${sourceSha}`);
              }

              const labels  = (pr.labels || []).map(l => l.name);
              const release = labels.filter(l => releaseAllowed.includes(l));
              const deploy  = labels.filter(l => deployAllowed.includes(l));

              if (release.length !== 1) {
                throw new Error(`release label must be exactly one. found=${release.join(",") || "none"}`);
              }
              if (deploy.length < 1) {
                throw new Error("at least one deploy label is required");
              }

              releaseLabel = release[0];
              deployLabels = deploy;
            }

            if (!releaseAllowed.includes(releaseLabel)) {
              throw new Error(`invalid release label: ${releaseLabel}`);
            }
            for (const label of deployLabels) {
              if (!deployAllowed.includes(label)) {
                throw new Error(`invalid deploy label: ${label}`);
              }
            }
            if (deployLabels.includes("deploy:customer-web")) {
              throw new Error("deploy:customer-web is manual only. use customer-web-manual-release workflow");
            }

            const releaseLevel = releaseLabel.replace("release:", "");

            core.setOutput("source_owner",      owner);
            core.setOutput("source_name",       repo);
            core.setOutput("source_sha",        sourceSha || "");
            core.setOutput("release_label",     releaseLabel);
            core.setOutput("release_level",     releaseLevel);
            core.setOutput("deploy_labels_json", JSON.stringify(deployLabels));

  create-tag:
    runs-on: ubuntu-latest
    needs: [resolve-context]
    if: needs.resolve-context.result == 'success' && needs.resolve-context.outputs.source_owner != '' && needs.resolve-context.outputs.source_name != ''
    outputs:
      version_tag: ${{ steps.bump.outputs.version_tag }}
      target_sha:  ${{ steps.bump.outputs.target_sha }}
    steps:
      - name: Guard required outputs
        shell: bash
        env:
          SOURCE_OWNER: ${{ needs.resolve-context.outputs.source_owner }}
          SOURCE_NAME: ${{ needs.resolve-context.outputs.source_name }}
          SOURCE_SHA: ${{ needs.resolve-context.outputs.source_sha }}
        run: |
          set -euo pipefail
          if [ -z "${SOURCE_OWNER}" ] || [ -z "${SOURCE_NAME}" ]; then
            echo "::error::resolve-context outputs source_owner/source_name are empty. Aborting to prevent checkout fallback to current repo."
            exit 1
          fi
          SOURCE_REPO="${SOURCE_OWNER}/${SOURCE_NAME}"
          echo "resolved-source-repo=$SOURCE_REPO"
          echo "resolved-source-sha=${SOURCE_SHA:-<empty>}"

      - name: Checkout source repo (at source sha)
        if: needs.resolve-context.outputs.source_sha != ''
        uses: actions/checkout@v4
        with:
          repository: ${{ format('{0}/{1}', needs.resolve-context.outputs.source_owner, needs.resolve-context.outputs.source_name) }}
          ref: ${{ needs.resolve-context.outputs.source_sha }}
          token: ${{ secrets.CENTRAL_REPO_TOKEN }}
          fetch-depth: 0

      - name: Checkout source repo (default branch)
        if: needs.resolve-context.outputs.source_sha == ''
        uses: actions/checkout@v4
        with:
          repository: ${{ format('{0}/{1}', needs.resolve-context.outputs.source_owner, needs.resolve-context.outputs.source_name) }}
          token: ${{ secrets.CENTRAL_REPO_TOKEN }}
          fetch-depth: 0

      - name: Validate source context
        shell: bash
        env:
          SOURCE_OWNER: ${{ needs.resolve-context.outputs.source_owner }}
          SOURCE_NAME: ${{ needs.resolve-context.outputs.source_name }}
          SOURCE_SHA: ${{ needs.resolve-context.outputs.source_sha }}
        run: |
          set -euo pipefail
          SOURCE_REPO="${SOURCE_OWNER}/${SOURCE_NAME}"
          echo "source-repo=$SOURCE_REPO"
          echo "source-sha=${SOURCE_SHA:-<empty>}"
          if [ -n "${SOURCE_SHA}" ]; then
            git cat-file -e "${SOURCE_SHA}^{commit}" || {
              echo "::error::source-sha does not exist in source-repo. source-repo=$SOURCE_REPO source-sha=$SOURCE_SHA"
              exit 1
            }
          fi

      - name: Bump semver and push tag
        id: bump
        shell: bash
        env:
          RELEASE_LEVEL: ${{ needs.resolve-context.outputs.release_level }}
          SOURCE_SHA:    ${{ needs.resolve-context.outputs.source_sha }}
        run: |
          set -euo pipefail

          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          TARGET_SHA="$SOURCE_SHA"
          if [ -z "$TARGET_SHA" ]; then
            TARGET_SHA="$(git rev-parse HEAD)"
          fi

          
          OBJECT_TYPE="$(git cat-file -t "$TARGET_SHA" 2>/dev/null || echo 'missing')"
          if [ "$OBJECT_TYPE" != "commit" ]; then
            echo "::error::TARGET_SHA=$TARGET_SHA is not a commit (type=$OBJECT_TYPE). Check that source-sha belongs to this repository." >&2
            exit 1
          fi

          LATEST_TAG="$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' --sort=-v:refname | head -n1)"
          if [ -z "$LATEST_TAG" ]; then
            LATEST_TAG="v0.0.0"
          fi

          BASE="${LATEST_TAG#v}"
          IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE"

          case "$RELEASE_LEVEL" in
            major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
            minor) MINOR=$((MINOR + 1)); PATCH=0 ;;
            patch) PATCH=$((PATCH + 1)) ;;
            *)
              echo "Unsupported RELEASE_LEVEL=$RELEASE_LEVEL" >&2
              exit 1
              ;;
          esac

          NEXT_TAG="v${MAJOR}.${MINOR}.${PATCH}"

          if git rev-parse "$NEXT_TAG" >/dev/null 2>&1; then
            echo "::error::Tag already exists: $NEXT_TAG" >&2
            exit 1
          fi

          git tag -a "$NEXT_TAG" "$TARGET_SHA" -m "release: $NEXT_TAG"
          git push origin "$NEXT_TAG"

          echo "version_tag=$NEXT_TAG" >> "$GITHUB_OUTPUT"
          echo "target_sha=$TARGET_SHA" >> "$GITHUB_OUTPUT"

  create-github-release:
    runs-on: ubuntu-latest
    needs: [resolve-context, create-tag]
    steps:
      - name: Create GitHub Release (source repo)
        uses: actions/github-script@v7
        env:
          SOURCE_OWNER:       ${{ needs.resolve-context.outputs.source_owner }}
          SOURCE_NAME:        ${{ needs.resolve-context.outputs.source_name }}
          VERSION_TAG:        ${{ needs.create-tag.outputs.version_tag }}
          TARGET_SHA:         ${{ needs.create-tag.outputs.target_sha }}
          RELEASE_LABEL:      ${{ needs.resolve-context.outputs.release_label }}
          DEPLOY_LABELS_JSON: ${{ needs.resolve-context.outputs.deploy_labels_json }}
        with:
          github-token: ${{ secrets.CENTRAL_REPO_TOKEN }}
          script: |
            const owner          = process.env.SOURCE_OWNER;
            const repo           = process.env.SOURCE_NAME;
            const tag            = process.env.VERSION_TAG;
            const targetSha      = process.env.TARGET_SHA;
            const releaseLabel   = process.env.RELEASE_LABEL;
            const deployLabels   = JSON.parse(process.env.DEPLOY_LABELS_JSON || "[]");

            try {
              const existing = await github.rest.repos.getReleaseByTag({ owner, repo, tag });
            
              core.notice(`Release already exists: ${existing.data.html_url}`);
              return;
            } catch (e) {
              if (e.status !== 404) throw e;
            }

            const header = [
              
              `release-label: ${releaseLabel}`,
              `deploy-labels: ${deployLabels.join(", ") || "none"}`
            ].join("\n");

            const created = await github.rest.repos.createRelease({
              owner,
              repo,
              tag_name:         tag,
              target_commitish: targetSha,
              
              name:             `${tag}`,
              body:             header,
              draft:            false,
              prerelease:       false,
              generate_release_notes: true
            });

        
            core.info(`Created release: ${created.data.html_url}`);

  build-and-push-api-server:
    runs-on: ubuntu-latest
    needs: [resolve-context, create-tag]
    if: contains(needs.resolve-context.outputs.deploy_labels_json, 'deploy:api-server')
    steps:
      - name: Resolve api-server source repository
        id: resolve-api-repo
        shell: bash
        env:
          SOURCE_OWNER: ${{ needs.resolve-context.outputs.source_owner }}
          SOURCE_NAME: ${{ needs.resolve-context.outputs.source_name }}
          DEFAULT_REPO: ${{ env.API_SERVER_SOURCE_REPO }}
        run: |
          set -euo pipefail
          if [[ "$SOURCE_NAME" == "api-server" ]]; then
            SOURCE_REPO="${SOURCE_OWNER}/${SOURCE_NAME}"
            echo "repo=$SOURCE_REPO" >> "$GITHUB_OUTPUT"
          else
            echo "repo=$DEFAULT_REPO" >> "$GITHUB_OUTPUT"
          fi

      - name: Checkout api-server
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.resolve-api-repo.outputs.repo }}
          token: ${{ secrets.CENTRAL_REPO_TOKEN }}
          fetch-depth: 0

      - name: Checkout source sha if source repo is api-server
        if: needs.resolve-context.outputs.source_name == 'api-server' && needs.resolve-context.outputs.source_sha != ''
        run: git checkout ${{ needs.resolve-context.outputs.source_sha }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push API images
        shell: bash
        env:
          VERSION_TAG: ${{ needs.create-tag.outputs.version_tag }}
        run: |
          set -euo pipefail

          ACCOUNT_ID="$(aws sts get-caller-identity --query Account --output text)"
          REGISTRY="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          REPO="${REGISTRY}/${API_SERVER_REPOSITORY}"
          CUSTOMER_TAG="customer-${VERSION_TAG}"
          ADMIN_TAG="admin-${VERSION_TAG}"

          if aws ecr describe-images --repository-name "${API_SERVER_REPOSITORY}" --image-ids imageTag="${CUSTOMER_TAG}" >/dev/null 2>&1; then
            echo "Skip push: ${REPO}:${CUSTOMER_TAG} already exists."
          else
            docker build --platform linux/amd64 \
              --build-arg PROFILE=customer \
              -t "${REPO}:${CUSTOMER_TAG}" \
              .
            docker push "${REPO}:${CUSTOMER_TAG}"
          fi

          if aws ecr describe-images --repository-name "${API_SERVER_REPOSITORY}" --image-ids imageTag="${ADMIN_TAG}" >/dev/null 2>&1; then
            echo "Skip push: ${REPO}:${ADMIN_TAG} already exists."
          else
            docker build --platform linux/amd64 \
              --build-arg PROFILE=admin \
              -t "${REPO}:${ADMIN_TAG}" \
              .
            docker push "${REPO}:${ADMIN_TAG}"
          fi

  build-and-push-admin-web:
    runs-on: ubuntu-latest
    needs: [resolve-context, create-tag]
    if: contains(needs.resolve-context.outputs.deploy_labels_json, 'deploy:admin-web')
    steps:
      - name: Resolve admin-web source repository
        id: resolve-admin-repo
        shell: bash
        env:
          SOURCE_OWNER: ${{ needs.resolve-context.outputs.source_owner }}
          SOURCE_NAME: ${{ needs.resolve-context.outputs.source_name }}
          DEFAULT_REPO: ${{ env.ADMIN_WEB_SOURCE_REPO }}
        run: |
          set -euo pipefail
          if [[ "$SOURCE_NAME" == "admin-fe" ]]; then
            SOURCE_REPO="${SOURCE_OWNER}/${SOURCE_NAME}"
            echo "repo=$SOURCE_REPO" >> "$GITHUB_OUTPUT"
          else
            echo "repo=$DEFAULT_REPO" >> "$GITHUB_OUTPUT"
          fi

      - name: Checkout admin-web
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.resolve-admin-repo.outputs.repo }}
          token: ${{ secrets.CENTRAL_REPO_TOKEN }}
          fetch-depth: 0

      - name: Checkout source sha if source repo is admin-web
        if: needs.resolve-context.outputs.source_name == 'admin-fe' && needs.resolve-context.outputs.source_sha != ''
        run: git checkout ${{ needs.resolve-context.outputs.source_sha }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Admin Web image
        shell: bash
        env:
          VERSION_TAG: ${{ needs.create-tag.outputs.version_tag }}
        run: |
          set -euo pipefail

          ACCOUNT_ID="$(aws sts get-caller-identity --query Account --output text)"
          REGISTRY="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          REPO="${REGISTRY}/${ADMIN_WEB_REPOSITORY}"
          if aws ecr describe-images --repository-name "${ADMIN_WEB_REPOSITORY}" --image-ids imageTag="${VERSION_TAG}" >/dev/null 2>&1; then
            echo "Skip push: ${REPO}:${VERSION_TAG} already exists."
          else
            docker build --platform linux/amd64 \
              -t "${REPO}:${VERSION_TAG}" \
              .
            docker push "${REPO}:${VERSION_TAG}"
          fi

  deploy-ecs:
    runs-on: ubuntu-latest
    needs:
      - resolve-context
      - create-tag
      - create-github-release
      - build-and-push-api-server
      - build-and-push-admin-web

    if: |
      always() &&
      needs.resolve-context.result == 'success' &&
      needs.create-tag.result == 'success' &&
      needs.create-github-release.result == 'success' &&
      (needs.build-and-push-api-server.result == 'success' || needs.build-and-push-api-server.result == 'skipped') &&
      (needs.build-and-push-admin-web.result == 'success' || needs.build-and-push-admin-web.result == 'skipped')
    steps:
      - name: Checkout infra repo
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Set up Java 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'

      - name: Install CDK CLI
        run: npm install -g aws-cdk@latest

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy ECS stack (image rollout)
        id: deploy-ecs
        shell: bash
        working-directory: infrastructure
        env:
          DEPLOY_MODE: ecs
          RELEASE_TAG: ${{ needs.create-tag.outputs.version_tag }}
          DEPLOY_LABELS_JSON: ${{ needs.resolve-context.outputs.deploy_labels_json }}
        run: |
          set -euo pipefail

          SERVICE_ROWS="$(aws cloudformation describe-stack-resources \
            --region "$AWS_REGION" \
            --stack-name EcsClusterStack \
            --query "StackResources[?ResourceType=='AWS::ECS::Service'].[LogicalResourceId,PhysicalResourceId]" \
            --output text || true)"

          current_tag_for_service_prefix() {
            local logical_prefix="$1"
            local fallback="$2"
            local service_arn=""
            local cluster_name=""
            local service_name=""
            local task_def_arn=""
            local image=""
            local image_no_digest=""

            service_arn="$(echo "$SERVICE_ROWS" | awk -v pfx="$logical_prefix" '$1 ~ "^"pfx {print $2; exit}')"
            if [ -z "$service_arn" ] || [ "$service_arn" = "None" ]; then
              echo "$fallback"
              return
            fi

            cluster_name="$(echo "$service_arn" | awk -F'/' '{print $(NF-1)}')"
            service_name="$(echo "$service_arn" | awk -F'/' '{print $NF}')"

            task_def_arn="$(aws ecs describe-services \
              --region "$AWS_REGION" \
              --cluster "$cluster_name" \
              --services "$service_name" \
              --query "services[0].taskDefinition" \
              --output text 2>/dev/null || true)"

            if [ -z "$task_def_arn" ] || [ "$task_def_arn" = "None" ]; then
              echo "$fallback"
              return
            fi

            image="$(aws ecs describe-task-definition \
              --region "$AWS_REGION" \
              --task-definition "$task_def_arn" \
              --query "taskDefinition.containerDefinitions[0].image" \
              --output text 2>/dev/null || true)"

            if [ -z "$image" ] || [ "$image" = "None" ]; then
              echo "$fallback"
              return
            fi

            image_no_digest="${image%@*}"
            if [[ "$image_no_digest" != *:* ]]; then
              echo "$fallback"
              return
            fi

            echo "${image_no_digest##*:}"
          }

          current_admin_web_tag="$(current_tag_for_service_prefix "AdminWebService" "latest")"
          current_admin_api_tag="$(current_tag_for_service_prefix "AdminApiService" "latest")"
          current_customer_api_tag="$(current_tag_for_service_prefix "CustomerApiService" "latest")"

          ADMIN_WEB_IMAGE_TAG="$current_admin_web_tag"
          ADMIN_API_IMAGE_TAG="$current_admin_api_tag"
          CUSTOMER_API_IMAGE_TAG="$current_customer_api_tag"

          if [[ "$DEPLOY_LABELS_JSON" == *"deploy:admin-web"* ]]; then
            ADMIN_WEB_IMAGE_TAG="$RELEASE_TAG"
          fi

          if [[ "$DEPLOY_LABELS_JSON" == *"deploy:api-server"* ]]; then
            ADMIN_API_IMAGE_TAG="admin-${RELEASE_TAG}"
            CUSTOMER_API_IMAGE_TAG="customer-${RELEASE_TAG}"
          fi

          export ADMIN_WEB_IMAGE_TAG
          export ADMIN_API_IMAGE_TAG
          export CUSTOMER_API_IMAGE_TAG

          {
            echo "admin_web_image_tag=$ADMIN_WEB_IMAGE_TAG"
            echo "admin_api_image_tag=$ADMIN_API_IMAGE_TAG"
            echo "customer_api_image_tag=$CUSTOMER_API_IMAGE_TAG"
          } >> "$GITHUB_OUTPUT"

          cdk deploy EcsClusterStack --exclusively --require-approval never

      - name: Summary
        run: |
          echo "release=${{ needs.create-tag.outputs.version_tag }}"
          echo "deploy_labels=${{ needs.resolve-context.outputs.deploy_labels_json }}"
          echo "admin_api_image_tag=${{ steps.deploy-ecs.outputs.admin_api_image_tag }}"
          echo "customer_api_image_tag=${{ steps.deploy-ecs.outputs.customer_api_image_tag }}"
          echo "admin_web_image_tag=${{ steps.deploy-ecs.outputs.admin_web_image_tag }}"
