name: Test Coverage (JaCoCo) - Reusable

on:
  workflow_call:
    inputs:
      java-version:
        type: string
        required: false
        default: "17"

      working-directory:
        type: string
        required: false
        default: "."

      gradle-args:
        type: string
        required: false
        default: "clean test jacocoTestReport --info"

      db-name:
        type: string
        required: false
        default: "worker_test"
      db-user:
        type: string
        required: false
        default: "postgres"
      db-password:
        type: string
        required: false
        default: "postgres"

      # thresholds are ratios (0.0 ~ 1.0)
      min-line-overall:
        type: number
        required: false
        default: 0.7
      min-branch-overall:
        type: number
        required: false
        default: 0.5

      min-line-changed:
        type: number
        required: false
        default: 0.7
      min-branch-changed:
        type: number
        required: false
        default: 0.5

      worst-classes-topn:
        type: number
        required: false
        default: 10
      worst-packages-topn:
        type: number
        required: false
        default: 10

jobs:
  coverage:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_DB: ${{ inputs['db-name'] }}
          POSTGRES_USER: ${{ inputs['db-user'] }}
          POSTGRES_PASSWORD: ${{ inputs['db-password'] }}
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U ${{ inputs['db-user'] }} -d ${{ inputs['db-name'] }}"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 10

    defaults:
      run:
        working-directory: ${{ inputs['working-directory'] }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Create DB roles for Flyway migration
        run: |
          psql -h localhost -U ${{ inputs['db-user'] }} -d ${{ inputs['db-name'] }} -c "
            DO \$\$
            BEGIN
              IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_admin') THEN
                CREATE ROLE app_admin;
              END IF;
              IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'db_migrator') THEN
                CREATE ROLE db_migrator;
              END IF;
            END
            \$\$;
          "
        env:
          PGPASSWORD: ${{ inputs['db-password'] }}
      
      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: ${{ inputs['java-version'] }}

      - name: Cache Gradle
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew

      - name: Build / Test / JaCoCo
        env:
          SPRING_PROFILES_ACTIVE: test
          SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/${{ inputs['db-name'] }}
          SPRING_DATASOURCE_USERNAME: ${{ inputs['db-user'] }}
          SPRING_DATASOURCE_PASSWORD: ${{ inputs['db-password'] }}
        run: ./gradlew ${{ inputs['gradle-args'] }}

      - name: Upload JaCoCo HTML report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: jacoco-html
          path: ${{ inputs['working-directory'] }}/build/reports/jacoco/test/html

      - name: Upload JaCoCo XML report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: jacoco-xml
          path: ${{ inputs['working-directory'] }}/build/reports/jacoco/test/jacocoTestReport.xml

      # Reusable workflowì—ì„œëŠ” event_nameì´ workflow_callì´ë¼ PR ì—¬ë¶€ëŠ” payloadë¡œ íŒë‹¨
      - name: Collect changed files (PR)
        if: always() && github.event.pull_request != null
        uses: actions/github-script@v7
        env:
          WD: ${{ inputs['working-directory'] }}
        with:
          script: |
            const path = require("path");
            const fs = require("fs");

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pr = context.payload.pull_request;
            if (!pr) {
              core.info("No pull_request payload. Skip changed files.");
              return;
            }

            let page = 1;
            const per_page = 100;
            let files = [];

            while (true) {
              const res = await github.rest.pulls.listFiles({ owner, repo, pull_number: pr.number, page, per_page });
              files = files.concat(res.data.map(f => f.filename));
              if (res.data.length < per_page) break;
              page++;
            }

            const outPath = path.join(process.env.GITHUB_WORKSPACE, process.env.WD || ".", "changed_files.json");
            fs.writeFileSync(outPath, JSON.stringify(files, null, 2), "utf8");
            core.info(`Saved changed files: ${files.length} -> ${outPath}`);

      - name: Build fancy coverage markdown
        if: always() && github.event.pull_request != null
        id: cov
        env:
          WD: ${{ inputs['working-directory'] }}
          MIN_LINE_OVERALL: ${{ inputs['min-line-overall'] }}
          MIN_BRANCH_OVERALL: ${{ inputs['min-branch-overall'] }}
          MIN_LINE_CHANGED: ${{ inputs['min-line-changed'] }}
          MIN_BRANCH_CHANGED: ${{ inputs['min-branch-changed'] }}
          TOPN_CLASSES: ${{ inputs['worst-classes-topn'] }}
          TOPN_PACKAGES: ${{ inputs['worst-packages-topn'] }}
        run: |
          python3 - <<'PY'
          import os, json
          import xml.etree.ElementTree as ET
          from datetime import datetime

          wd = os.getenv("WD") or "."
          xml_path = os.path.join(wd, "build/reports/jacoco/test/jacocoTestReport.xml")
          changed_json_path = os.path.join(wd, "changed_files.json")

          min_line_overall = float(os.getenv("MIN_LINE_OVERALL") or 0.0) * 100.0
          min_branch_overall = float(os.getenv("MIN_BRANCH_OVERALL") or 0.0) * 100.0
          min_line_changed = float(os.getenv("MIN_LINE_CHANGED") or 0.0) * 100.0
          min_branch_changed = float(os.getenv("MIN_BRANCH_CHANGED") or 0.0) * 100.0

          topn_classes = int(float(os.getenv("TOPN_CLASSES") or 10))
          topn_packages = int(float(os.getenv("TOPN_PACKAGES") or 10))

          def pct_or_none(covered, missed):
            total = covered + missed
            if total == 0:
              return None
            return round((covered / total) * 100.0, 1)

          def bar(p, blocks=20):
            if p is None:
              return "â–‘" * blocks
            p = max(0.0, min(100.0, float(p)))
            filled = int(round((p/100.0)*blocks))
            return ("â–ˆ"*filled) + ("â–‘"*(blocks-filled))

          def spark(values):
            ticks = "â–â–‚â–ƒâ–„â–…â–†â–‡â–ˆ"
            out = []
            for v in values:
              if v is None:
                out.append("Â·")
                continue
              v = max(0.0, min(100.0, float(v)))
              idx = int(round((v/100.0)*(len(ticks)-1)))
              out.append(ticks[idx])
            return "".join(out)

          def ok_icon(value, threshold):
            if value is None:
              return "âœ…"
            return "âœ…" if value >= threshold else "âš ï¸"

          def fmt(value):
            return "N/A" if value is None else f"{value}%"

          def counter_map(elem):
            d = {}
            for c in elem.findall("counter"):
              t = c.attrib.get("type")
              missed = int(c.attrib.get("missed", "0"))
              covered = int(c.attrib.get("covered", "0"))
              d[t] = (missed, covered)
            return d

          def get_line_branch(elem):
            d = counter_map(elem)
            lm, lc = d.get("LINE", (0,0))
            bm, bc = d.get("BRANCH", (0,0))
            linep = pct_or_none(lc, lm)
            branchp = pct_or_none(bc, bm)
            return linep, branchp, (lm+lc), (bm+bc), (lm, lc, bm, bc)

          if not os.path.exists(xml_path):
            md = f"""## ğŸ§ª Test Coverage Report (JaCoCo)

          â— JaCoCo XML not found: `{xml_path}`

          - Ensure Gradle args include: `jacocoTestReport`
          - Expected XML: `build/reports/jacoco/test/jacocoTestReport.xml`
          """
            with open(os.path.join(wd, "coverage_comment.md"), "w", encoding="utf-8") as f:
              f.write(md)
          else:
            tree = ET.parse(xml_path)
            root = tree.getroot()

            overall_line, overall_branch, _, _, _ = get_line_branch(root)

            changed_files = []
            if os.path.exists(changed_json_path):
              with open(changed_json_path, "r", encoding="utf-8") as f:
                changed_files = json.load(f)

            changed_java = [p for p in changed_files if p.endswith(".java") and "src/main/java/" in p]

            srcfile_index = {}
            pkg_stats = []
            class_stats = []

            for pkg in root.findall("package"):
              pkg_slash = pkg.attrib.get("name", "")
              pkg_dot = pkg_slash.replace("/", ".") if pkg_slash else "(default)"
              p_line, p_branch, p_lines_total, _, _ = get_line_branch(pkg)
              pkg_stats.append((pkg_dot, p_line, p_branch, p_lines_total, pkg_slash))

              for sf in pkg.findall("sourcefile"):
                name = sf.attrib.get("name", "")
                sf_line, sf_branch, sf_lines_total, _, raw = get_line_branch(sf)
                srcfile_index[(pkg_slash, name)] = (sf_line, sf_branch, sf_lines_total, raw)

              for cl in pkg.findall("class"):
                cn = cl.attrib.get("name", "").replace("/", ".")
                c_line, c_branch, c_lines_total, _, _ = get_line_branch(cl)
                if c_lines_total >= 10:
                  class_stats.append((cn, c_line, c_branch, c_lines_total))

            pkg_stats_sorted = sorted(pkg_stats, key=lambda x: ((x[1] if x[1] is not None else 101), -x[3]))
            worst_pkgs = pkg_stats_sorted[:topn_packages]

            class_stats_sorted = sorted(class_stats, key=lambda x: ((x[1] if x[1] is not None else 101), -x[3]))
            worst_classes = class_stats_sorted[:topn_classes]

            def split_java_path(p):
              after = p.split("src/main/java/", 1)[1]
              parts = after.split("/")
              if len(parts) == 1:
                return ("", parts[0])
              pkg = "/".join(parts[:-1])
              return (pkg, parts[-1])

            agg_lm = agg_lc = agg_bm = agg_bc = 0
            changed_rows = []

            for pth in changed_java:
              pkg_slash, fname = split_java_path(pth)
              key = (pkg_slash, fname)

              if key in srcfile_index:
                linep, branchp, lines_total, raw = srcfile_index[key]
                lm, lc, bm, bc = raw
              else:
                matches = [v for k,v in srcfile_index.items() if k[1] == fname]
                if matches:
                  lm = sum(m[3][0] for m in matches); lc = sum(m[3][1] for m in matches)
                  bm = sum(m[3][2] for m in matches); bc = sum(m[3][3] for m in matches)
                  linep = pct_or_none(lc, lm)
                  branchp = pct_or_none(bc, bm)
                  lines_total = lm + lc
                else:
                  lm = lc = bm = bc = 0
                  linep = branchp = None
                  lines_total = 0

              agg_lm += lm; agg_lc += lc
              agg_bm += bm; agg_bc += bc
              changed_rows.append((pth, linep, branchp, lines_total))

            changed_line = pct_or_none(agg_lc, agg_lm)
            changed_branch = pct_or_none(agg_bc, agg_bm)
            changed_na = (len(changed_java) == 0)

            pkg_sample = sorted(pkg_stats, key=lambda x: x[0])[:30]
            pkg_line_spark = spark([p[1] for p in pkg_sample]) if pkg_sample else ""
            pkg_branch_spark = spark([p[2] for p in pkg_sample]) if pkg_sample else ""

            now = datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC")

            overall_line_icon = ok_icon(overall_line, min_line_overall)
            overall_branch_icon = ok_icon(overall_branch, min_branch_overall)
            changed_line_icon = "âœ…" if changed_na else ok_icon(changed_line, min_line_changed)
            changed_branch_icon = "âœ…" if changed_na else ok_icon(changed_branch, min_branch_changed)

            def badge(label, value):
              if value is None:
                val = "N/A"; color = "lightgrey"
              else:
                v = float(value)
                color = "brightgreen" if v >= 80 else ("green" if v >= 60 else ("orange" if v >= 30 else "red"))
                val = f"{v}%"
              val_enc = val.replace("%", "%25")
              label = label.replace("-", "--").replace("_", "__")
              return f"![{label}](https://img.shields.io/badge/{label}-{val_enc}-{color})"

            md = []
            md.append("## ğŸ§ª Test Coverage Report (JaCoCo)")
            md.append(
              f"{badge('overall_line', overall_line)} {badge('overall_branch', overall_branch)}  "
              f"{badge('changed_line', (None if changed_na else changed_line))} {badge('changed_branch', (None if changed_na else changed_branch))}"
            )
            md.append(
              f"> ê¸°ì¤€(soft, workflowëŠ” ì‹¤íŒ¨ ì•ˆ í•¨): "
              f"Overall **line {min_line_overall:.0f}% / branch {min_branch_overall:.0f}%**, "
              f"Changed **line {min_line_changed:.0f}% / branch {min_branch_changed:.0f}%**  Â·  Generated: {now}"
            )
            md.append("")
            md.append("| Scope | Line | Branch | Line Graph | Branch Graph | Verdict |")
            md.append("|---|---:|---:|:---:|:---:|:---:|")
            md.append(f"| **Overall** | **{fmt(overall_line)}** | **{fmt(overall_branch)}** | `{bar(overall_line)}` | `{bar(overall_branch)}` | {overall_line_icon}{overall_branch_icon} |")
            if changed_na:
              md.append(f"| **Changed** | **N/A** | **N/A** | `{'â–‘'*20}` | `{'â–‘'*20}` | âœ…âœ… |")
            else:
              md.append(f"| **Changed** | **{fmt(changed_line)}** | **{fmt(changed_branch)}** | `{bar(changed_line)}` | `{bar(changed_branch)}` | {changed_line_icon}{changed_branch_icon} |")
            md.append("")
            if pkg_line_spark:
              md.append(f"**Package line spark (sample)**: `{pkg_line_spark}`")
            if pkg_branch_spark:
              md.append(f"**Package branch spark (sample)**: `{pkg_branch_spark}`")
            if pkg_line_spark or pkg_branch_spark:
              md.append("")
            md.append(f"### ğŸ“¦ Package coverage (worst {topn_packages})")
            md.append("| Rank | Package | Line | Branch | Lines | Line Graph | Branch Graph |")
            md.append("|---:|---|---:|---:|---:|:---:|:---:|")
            for i, (pkg_dot, linep, branchp, lines_total, _) in enumerate(worst_pkgs, 1):
              md.append(f"| {i} | `{pkg_dot}` | **{fmt(linep)}** | **{fmt(branchp)}** | {lines_total} | `{bar(linep)}` | `{bar(branchp)}` |")
            md.append("")
            md.append(f"### ğŸ§¨ Lowest coverage classes (worst {topn_classes})")
            md.append("| Rank | Class | Line | Branch | Lines | Line Graph | Branch Graph |")
            md.append("|---:|---|---:|---:|---:|:---:|:---:|")
            for i, (cn, linep, branchp, lines_total) in enumerate(worst_classes, 1):
              md.append(f"| {i} | `{cn}` | **{fmt(linep)}** | **{fmt(branchp)}** | {lines_total} | `{bar(linep)}` | `{bar(branchp)}` |")
            md.append("")
            md.append("<details>")
            md.append(f"<summary>ğŸ§© Changed files coverage breakdown ({len(changed_java)} files)</summary>")
            md.append("")
            if changed_na:
              md.append("_No changed Java files under `src/main/java`._")
            else:
              md.append("| File | Line | Branch | Lines | Verdict | Line Graph | Branch Graph |")
              md.append("|---|---:|---:|---:|:---:|:---:|:---:|")
              for pth, linep, branchp, lines_total in sorted(changed_rows, key=lambda x: (x[1] if x[1] is not None else 101)):
                verdict = f"{ok_icon(linep, min_line_changed)}{ok_icon(branchp, min_branch_changed)}"
                md.append(f"| `{pth}` | **{fmt(linep)}** | **{fmt(branchp)}** | {lines_total} | {verdict} | `{bar(linep)}` | `{bar(branchp)}` |")
            md.append("")
            md.append("</details>")
            md.append("")
            md.append("---")
            md.append("ğŸ” HTML ë¦¬í¬íŠ¸: Actions â†’ Artifacts â†’ `jacoco-html`  Â·  XML: `jacoco-xml`")
            md.append("")

            with open(os.path.join(wd, "coverage_comment.md"), "w", encoding="utf-8") as f:
              f.write("\n".join(md))

          out_path = os.environ["GITHUB_OUTPUT"]
          with open(os.path.join(wd, "coverage_comment.md"), "r", encoding="utf-8") as f:
            body = f.read()
          with open(out_path, "a", encoding="utf-8") as out:
            out.write("markdown<<EOF\n")
            out.write(body)
            out.write("\nEOF\n")
          PY

      - name: Post/Update fancy coverage comment
        if: always() && github.event.pull_request != null
        uses: actions/github-script@v7
        env:
          BODY: ${{ steps.cov.outputs.markdown }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pr = context.payload.pull_request;
            if (!pr) return;

            const marker = "<!-- JACOCO_FANCY_COVERAGE -->";
            const body = (process.env.BODY || "").trim();
            if (!body) return;

            const content = `${marker}\n${body}`;
            const comments = await github.rest.issues.listComments({ owner, repo, issue_number: pr.number, per_page: 100 });
            const mine = comments.data.find(c => c.user?.login === "github-actions[bot]" && c.body?.includes(marker));

            if (mine) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: mine.id, body: content });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number: pr.number, body: content });
            }
